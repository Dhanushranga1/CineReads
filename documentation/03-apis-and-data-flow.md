# CineReads - APIs & Data Flow

## Navigation
- **Previous**: [02-technical-implementation.md](./02-technical-implementation.md)
- **Current**: 03-apis-and-data-flow.md
- **Next**: [04-code-quality-and-gaps.md](./04-code-quality-and-gaps.md)
- **Related**: [01-overview-and-architecture.md](./01-overview-and-architecture.md)

---

## Table of Contents
1. [API Endpoints Reference](#api-endpoints-reference)
2. [Data Models & Schema](#data-models--schema)
3. [External API Integrations](#external-api-integrations)
4. [Data Flow Analysis](#data-flow-analysis)
5. [User Flows & Features](#user-flows--features)
6. [Cache Architecture](#cache-architecture)
7. [Dependencies & Integrations](#dependencies--integrations)

---

## API Endpoints Reference

### Internal API Endpoints (Backend)

#### POST `/api/recommend`
**Location**: `backend/app/routers/recommendations.py:25`
**Purpose**: Generate book recommendations based on movie preferences

**Request Format**:
```json
{
  "movies": ["The Matrix", "Blade Runner", "Inception"],
  "preferences": {
    "mood": "thought-provoking",
    "pace": "medium",
    "genre_preferences": ["science-fiction", "philosophy"],
    "genre_blocklist": ["romance", "horror"]
  }
}
```

**Response Format**:
```json
{
  "recommendations": [
    {
      "movie": "Based on your interest in The Matrix, Blade Runner, Inception",
      "books": [
        {
          "title": "Neuromancer",
          "author": "William Gibson",
          "reason": "This novel explores the intersection of humanity and technology...",
          "rating": 3.8,
          "cover_url": "https://assets.hardcover.app/editions/30401722/203725739738019-PxOL.jpg",
          "hardcover_url": "https://hardcover.app/books/neuromancer",
          "taste_match_score": 0.95,
          "primary_appeal": "Existential and philosophical themes",
          "genre_tags": ["science-fiction", "cyberpunk"],
          "complexity_level": "complex",
          "isbn": "9780441569595",
          "publication_year": 1984,
          "page_count": 271,
          "publisher": "Ace Books",
          "hardcover_id": 268150,
          "users_count": 45672,
          "description": "The Matrix inside a computer..."
        }
      ],
      "taste_profile": {
        "themes": ["Existentialism", "Rebellion", "Self-Discovery"],
        "narrative_style": "Complex, layered storytelling with unexpected twists",
        "emotional_tone": "Dark, introspective, and thought-provoking",
        "genre_fusion": "Science fiction blended with philosophical elements",
        "character_preferences": "Protagonists who are flawed, yet determined",
        "artistic_sensibilities": "Visually striking, atmospheric, and immersive",
        "confidence_score": 0.85
      },
      "recommendation_type": "unified"
    }
  ],
  "insights": {
    "total_movies_analyzed": 3,
    "dominant_themes": ["Existentialism", "Rebellion", "Self-Discovery"],
    "genre_diversity_score": 0.8,
    "recommendation_confidence": 0.85,
    "alternative_suggestions": ["Consider exploring dystopian fiction"]
  },
  "processing_time": 2.34,
  "cache_hit": false
}
```

**Query Parameters**:
- `include_insights` (bool, default: true): Include recommendation insights
- `recommendation_type` (str, default: "unified"): "unified" or "individual"

**HTTP Status Codes**:
- `200`: Success
- `400`: Bad request (validation error)
- `500`: Internal server error

**Authentication**: None required

**Rate Limiting**: 
- Max 5 movies per request
- External API rate limits apply (OpenAI, Hardcover)

---

#### POST `/api/regenerate`
**Location**: `backend/app/routers/recommendations.py` (implied from frontend usage)
**Purpose**: Force regeneration of recommendations (bypass cache)

**Request/Response**: Same as `/api/recommend`
**Behavior**: Skips cache lookup, always generates fresh recommendations

---

#### GET `/health`
**Location**: `backend/app/main.py:130`
**Purpose**: Health check endpoint for monitoring

**Response**:
```json
{
  "status": "healthy",
  "timestamp": "2025-01-11T19:45:30.123456",
  "version": "1.0.0"
}
```

---

#### GET `/`
**Location**: `backend/app/main.py:135`
**Purpose**: Root endpoint redirect

**Response**: Redirects to `/docs` (FastAPI documentation)

---

#### GET `/docs`
**Location**: Auto-generated by FastAPI
**Purpose**: Interactive API documentation (Swagger UI)

#### GET `/redoc`
**Location**: Auto-generated by FastAPI  
**Purpose**: Alternative API documentation (ReDoc)

---

## Data Models & Schema

### Request Models (`backend/app/models/request_models.py`)

#### `UserPreferences`
```python
class UserPreferences(BaseModel):
    mood: Optional[str] = None                    # "thought-provoking", "light", "intense"
    pace: Optional[str] = None                    # "slow", "medium", "fast"
    genre_preferences: Optional[List[str]] = None # Preferred genres
    genre_blocklist: Optional[List[str]] = None   # Genres to avoid
```

**Validation**:
- All fields optional
- String fields: Max length 100 characters
- List fields: Max 10 items each

#### `RecommendationRequest`
```python
class RecommendationRequest(BaseModel):
    movies: List[str]                             # 1-5 movie titles
    preferences: Optional[UserPreferences] = None # User preferences
```

**Validation**:
- `movies`: Required, 1-5 items, non-empty strings
- `preferences`: Optional user preferences object

### Response Models (`backend/app/models/response_models.py`)

#### `BookRecommendation`
```python
class BookRecommendation(BaseModel):
    # Core recommendation fields
    title: str                                    # Book title
    author: str                                   # Primary author
    reason: str                                   # Why this book matches
    
    # Hardcover API metadata
    rating: Optional[float] = None                # Average rating (0-5)
    cover_url: Optional[str] = None               # Book cover image URL
    hardcover_url: Optional[str] = None           # Hardcover.app book page
    
    # Enhanced recommendation data
    taste_match_score: Optional[float] = None     # AI-generated match score (0-1)
    primary_appeal: Optional[str] = None          # Main reason for recommendation
    genre_tags: Optional[List[str]] = None        # Genre classifications
    complexity_level: Optional[str] = None        # "light", "medium", "complex"
    
    # Additional metadata
    isbn: Optional[str] = None                    # ISBN identifier
    publication_year: Optional[int] = None        # Publication year
    page_count: Optional[int] = None              # Number of pages
    publisher: Optional[str] = None               # Publisher name
    hardcover_id: Optional[int] = None            # Hardcover database ID
    users_count: Optional[int] = None             # Number of users who read it
    description: Optional[str] = None             # Book description
```

#### `TasteProfile`
```python
class TasteProfile(BaseModel):
    themes: List[str]                             # Dominant themes from movies
    narrative_style: str                          # Storytelling preferences
    emotional_tone: str                           # Preferred emotional register
    genre_fusion: str                             # Genre preferences and blending
    character_preferences: str                    # Character archetype preferences
    artistic_sensibilities: str                   # Aesthetic and style preferences
    confidence_score: Optional[float] = None      # AI confidence in analysis (0-1)
```

#### `RecommendationResponse`
```python
class RecommendationResponse(BaseModel):
    movie: str                                    # Movie context or taste summary
    books: List[BookRecommendation]               # List of recommended books
    taste_profile: Optional[TasteProfile] = None  # User's analyzed taste profile
    recommendation_type: str = "unified"          # "unified" or "individual"
```

#### `RecommendationInsights`
```python
class RecommendationInsights(BaseModel):
    total_movies_analyzed: int                    # Number of movies processed
    dominant_themes: List[str]                    # Most common themes identified
    genre_diversity_score: float                  # Genre diversity metric (0-1)
    recommendation_confidence: float              # Overall confidence (0-1)
    alternative_suggestions: Optional[List[str]] = None # Additional suggestions
```

#### `EnhancedRecommendationResponse`
```python
class EnhancedRecommendationResponse(BaseModel):
    recommendations: List[RecommendationResponse] # Main recommendation data
    insights: RecommendationInsights              # Analytics and insights
    processing_time: Optional[float] = None       # Request processing time (seconds)
    cache_hit: bool                               # Whether result was cached
```

### Frontend Type Definitions (`frontend/src/types/index.ts`)

#### `Movie`
```typescript
export interface Movie {
  id: number;                    // TMDB movie ID
  title: string;                 // Movie title
  poster_path?: string | null;   // TMDB poster path
  poster_url?: string | null;    // Full poster URL
  release_date?: string | null;  // Release date (YYYY-MM-DD)
  overview?: string | null;      // Movie synopsis
  vote_average?: number;         // TMDB rating
  popularity?: number;           // TMDB popularity score
}
```

#### `UserPreferences`
```typescript
export interface UserPreferences {
  mood?: string | null;                // User's mood preference
  pace?: string | null;                // Preferred reading pace
  genre_preferences?: string[] | null; // Preferred genres
  genre_blocklist?: string[] | null;   // Genres to avoid
}
```

**Note**: Frontend and backend `UserPreferences` are identical by design for consistency.

---

## External API Integrations

### OpenAI/Groq API Integration

#### Configuration
```python
# Service initialization in GPTService
self.client = openai.AsyncOpenAI(
    api_key=settings.openai_api_key,
    base_url=settings.openai_base_url  # Can be Groq or OpenAI
)
```

#### Request Format
```python
response = await self.client.chat.completions.create(
    model=settings.gpt_model,  # "gpt-4o-mini" or "llama-3.3-70b-versatile"
    messages=[
        {"role": "system", "content": self._get_system_prompt()},
        {"role": "user", "content": prompt}
    ],
    max_tokens=2000,
    temperature=0.3
)
```

**API Endpoints Used**:
- OpenAI: `https://api.openai.com/v1/chat/completions`
- Groq: `https://api.groq.com/openai/v1/chat/completions`

**Authentication**: Bearer token (API key)

**Rate Limits**:
- OpenAI: Varies by plan (typically 3500 requests/minute)
- Groq: 30 requests/minute (free tier)

**Error Handling**:
- Connection errors: Fallback response generation
- Rate limit errors: Exponential backoff (not implemented)
- Invalid responses: JSON parsing with multiple strategies

---

### Hardcover API Integration

#### Configuration
```python
class HardcoverService:
    def __init__(self):
        self.api_url = "https://api.hardcover.app/v1/graphql"
        self.api_key = settings.hardcover_api_key  # JWT token
        self.timeout = 10  # seconds
        self.retry_attempts = 3
```

#### GraphQL Query Example
```graphql
query SearchBooks($searchQuery: String!, $perPage: Int!, $page: Int!) {
  search(query: $searchQuery, query_type: "books", per_page: $perPage, page: $page, sort: "activities_count:desc") {
    results
    page
    per_page
    query
    error
  }
}
```

**Variables**:
```json
{
  "searchQuery": "Neuromancer William Gibson",
  "perPage": 10,
  "page": 1
}
```

**Response Structure**:
```json
{
  "data": {
    "search": {
      "results": "{\"facet_counts\":[],\"found\":8,\"hits\":[{\"document\":{\"id\":\"268150\",\"title\":\"Neuromancer\",\"author_names\":[\"William Gibson\"],\"image\":{\"url\":\"https://assets.hardcover.app/editions/30401722/203725739738019-PxOL.jpg\"},\"rating\":3.796979865771812,\"slug\":\"neuromancer\"}}]}",
      "page": 1,
      "per_page": 10,
      "query": "Neuromancer William Gibson",
      "error": null
    }
  }
}
```

**Authentication**: 
```http
Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJIYXJkY292ZXIi...
```

**Rate Limits**: 60 requests/minute

**Search Strategies**:
1. `"Title Author"` - Combined search
2. `"Title"` - Title only
3. `"Cleaned Title"` - Stop words removed
4. `"Author Title"` - Reversed order

**Matching Algorithm**:
- Title similarity scoring (Levenshtein distance)
- Author name matching
- Popularity weighting
- Minimum score threshold: 7.0

---

### TMDB API Integration

#### Configuration
```typescript
class TMDBService {
  private apiKey = '473496e0286c39ee2c92ec60c58ac047';
  private readAccessToken = 'eyJhbGciOiJIUzI1NiJ9...';
  private baseURL = 'https://api.themoviedb.org/3';
}
```

#### Movie Search Request
```typescript
const url = `${TMDB_BASE_URL}/search/movie?query=${encodeURIComponent(query)}&language=en-US&page=1&include_adult=false&sort_by=popularity.desc`;

const response = await fetch(url, {
  method: 'GET',
  headers: {
    'Accept': 'application/json',
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${this.readAccessToken}`
  }
});
```

**Response Format**:
```json
{
  "results": [
    {
      "id": 603,
      "title": "The Matrix",
      "poster_path": "/f89U3ADr1oiB1s9GkdPOEpXUk5H.jpg",
      "release_date": "1999-03-30",
      "vote_average": 8.2,
      "overview": "Set in the 22nd century...",
      "popularity": 45.6
    }
  ],
  "total_results": 1,
  "total_pages": 1
}
```

**Image URL Construction**:
```typescript
poster_url: movie.poster_path ? 
  `https://image.tmdb.org/t/p/w500${movie.poster_path}` : null
```

**Rate Limits**: 40 requests per 10 seconds

**Authentication**: Bearer token (Read Access Token)

---

## Data Flow Analysis

### Complete Request Flow

#### 1. User Input Flow
```
User Types Movie → Debounced Search → TMDB API → Movie Suggestions → User Selection
                     (300ms delay)      (Search)    (Display)      (Add to list)
```

**Code Path**:
1. `MovieInput.tsx:useEffect` triggers on input change
2. `tmdbService.searchMovies()` calls TMDB API
3. Results displayed in dropdown
4. User clicks → movie added to `movies` state array

#### 2. Recommendation Generation Flow
```
Click "Get Recommendations" 
    ↓
Validate Input (min 1 movie)
    ↓
Create Cache Key (movies + preferences + type)
    ↓
Check Cache → [HIT] Return cached result
    ↓         [MISS] Continue to API
Generate AI Recommendations (GPT/Groq)
    ↓
Enhance with Book Metadata (Hardcover API)
    ↓
Generate Insights
    ↓
Cache Result
    ↓
Return to Frontend
```

**Code Path**:
```
page.tsx:getRecommendations()
    ↓
api.ts:getRecommendations()
    ↓
POST /api/recommend
    ↓
recommendations.py:get_recommendations()
    ↓
[Cache Check] cache_service.get()
    ↓ [MISS]
gpt_service.generate_recommendations()
    ↓
_enhance_with_metadata()
    ↓
[For each book] enhance_book_with_metadata()
    ↓
hardcover_service.get_book_metadata()
    ↓
cache_service.set() [Store result]
    ↓
Return EnhancedRecommendationResponse
```

#### 3. Cache Flow Architecture
```
Request → Generate Cache Key → Check File System → [HIT] Return Data
                                      ↓ [MISS]
                                API Call → Store in Cache → Return Data
```

**Cache Key Generation**:
```python
def create_recommendation_cache_key(movies: List[str], preferences: Optional[Dict], rec_type: str) -> str:
    # Normalize inputs
    movies_normalized = sorted([movie.lower().strip() for movie in movies])
    preferences_normalized = json.dumps(preferences or {}, sort_keys=True)
    
    # Create deterministic key
    key_data = f"{movies_normalized}:{preferences_normalized}:{rec_type}"
    return hashlib.md5(key_data.encode()).hexdigest()
```

**Cache Directory Structure**:
```
cache/
├── recommendations/
│   ├── a1b2c3d4e5f6.json    # Cached recommendation responses
│   └── f6e5d4c3b2a1.json
├── books/
│   ├── neuromancer_gibson.json  # Book metadata cache
│   └── dune_herbert.json
└── taste_profiles/
    └── [future use]
```

#### 4. Error Propagation Flow
```
API Error → Service Layer → Router Layer → HTTP Response → Frontend → User Display
     ↓           ↓              ↓             ↓             ↓            ↓
Log Error → Return Fallback → HTTP 500 → Parse Error → setState(error) → Show Message
```

### Data Transformation Points

#### 1. Movie Data Transformation
**TMDB → Frontend**:
```typescript
// TMDB format
{
  id: 603,
  title: "The Matrix",
  poster_path: "/f89U3ADr1oiB1s9GkdPOEpXUk5H.jpg"
}

// Transformed to
{
  id: 603,
  title: "The Matrix",
  poster_path: "/f89U3ADr1oiB1s9GkdPOEpXUk5H.jpg",
  poster_url: "https://image.tmdb.org/t/p/w500/f89U3ADr1oiB1s9GkdPOEpXUk5H.jpg"
}
```

#### 2. AI Response Transformation
**GPT Response → BookRecommendation**:
```python
# AI returns JSON
{
  "unified_recommendations": [
    {
      "title": "Neuromancer",
      "author": "William Gibson",
      "reason": "This novel explores...",
      "taste_match_score": 0.95
    }
  ]
}

# Transformed to Pydantic model
BookRecommendation(
    title="Neuromancer",
    author="William Gibson", 
    reason="This novel explores...",
    taste_match_score=0.95,
    # Additional fields populated by Hardcover
    cover_url=None,  # Will be populated later
    rating=None      # Will be populated later
)
```

#### 3. Hardcover Enhancement
**Before Enhancement**:
```python
BookRecommendation(
    title="Neuromancer",
    author="William Gibson",
    cover_url=None,
    rating=None,
    hardcover_url=None
)
```

**After Enhancement**:
```python
BookRecommendation(
    title="Neuromancer", 
    author="William Gibson",
    cover_url="https://assets.hardcover.app/editions/30401722/203725739738019-PxOL.jpg",
    rating=3.8,
    hardcover_url="https://hardcover.app/books/neuromancer",
    users_count=45672,
    description="The Matrix inside a computer..."
)
```

---

## User Flows & Features

### Core User Journey

#### 1. Movie Selection Flow
```
Load Page → See Movie Input → Type Movie Name → See Suggestions → Select Movie → Add to List
     ↓              ↓              ↓               ↓              ↓            ↓
page.tsx    MovieInput.tsx   tmdbService     Dropdown UI    onClick     movies array
```

**User Actions**:
1. **Type in search box**: Triggers debounced TMDB search
2. **Click suggestion**: Adds movie to selected list
3. **Remove movie**: Click X button to remove from list
4. **Add multiple movies**: Repeat process (max 5 movies)

**UI States**:
- **Empty**: "Search for movies..." placeholder
- **Loading**: Spinner in search box
- **Results**: Dropdown with movie posters and info
- **Selected**: Pills showing selected movies with remove buttons
- **Max reached**: Input disabled when 5 movies selected

#### 2. Preferences Configuration Flow
```
Click "Preferences" → Open Panel → Select Options → Apply Preferences
        ↓               ↓             ↓              ↓
   Toggle button   PreferencesPanel  Checkbox/Select  preferences state
```

**Preference Options**:
- **Mood**: "light", "thought-provoking", "intense", "emotional"
- **Pace**: "slow", "medium", "fast"
- **Genre Preferences**: Multi-select from predefined list
- **Genre Blocklist**: Genres to avoid

**UI Components**:
- Modal/panel overlay
- Checkbox groups for genres
- Radio buttons for mood/pace
- Clear/reset functionality

#### 3. Recommendation Generation Flow
```
Click "Get Recommendations" → Show Loading → API Call → Display Results → Show Book Cards
          ↓                      ↓           ↓            ↓               ↓
     Validate input         Loading spinner  Backend    Results state   BookCard components
```

**Loading States**:
- **Button**: Changes to "Generating..." with spinner
- **Content Area**: Loading message with animation
- **Duration**: Typically 2-5 seconds depending on cache hit

**Result Display**:
- **Book cards**: Cover image, title, author, rating
- **Reason**: AI-generated explanation for each recommendation
- **Metadata**: Genre tags, page count, publication year
- **Links**: External links to Hardcover for more info

#### 4. Result Interaction Flow
```
View Results → Click Book Card → Expand Details → Click External Link → Visit Hardcover
     ↓              ↓               ↓                ↓                    ↓
BookCard.tsx   Animation        More info      Open new tab        External site
```

**Interaction Features**:
- **Hover effects**: 3D transforms and brightness changes
- **Click to expand**: More book details (future enhancement)
- **External links**: Direct links to Hardcover book pages
- **Regenerate**: Option to get fresh recommendations

### Feature Implementation Details

#### 1. Movie Search Feature
**Location**: `frontend/src/components/MovieInput.tsx`

**Key Features**:
- **Debounced search**: 300ms delay to avoid excessive API calls
- **Keyboard navigation**: Arrow keys to navigate suggestions
- **Search history**: Tracks previous searches (localStorage)
- **Error handling**: Graceful failure with empty results
- **Mobile optimization**: Touch-friendly interface

**Implementation Highlights**:
```tsx
// Debounced search effect
useEffect(() => {
  const searchMovies = async () => {
    if (inputValue.trim().length < 2) return;
    
    setIsLoading(true);
    try {
      const results = await tmdbService.searchMovies(inputValue.trim());
      setSuggestions(results.slice(0, 10));
      setShowSuggestions(true);
    } catch (error) {
      setSuggestions([]);
    } finally {
      setIsLoading(false);
    }
  };

  const timeoutId = setTimeout(searchMovies, 300);
  return () => clearTimeout(timeoutId);
}, [inputValue]);
```

#### 2. Recommendation Display Feature
**Location**: `frontend/src/components/RecommendationResult.tsx`

**Key Features**:
- **Staggered animations**: Books appear with delay
- **Responsive layout**: Adapts to screen size
- **Empty state**: Meaningful message when no results
- **Regenerate option**: Fresh recommendations without cache

#### 3. Book Card Feature
**Location**: `frontend/src/components/BookCard.tsx`

**Key Features**:
- **Progressive image loading**: Shows placeholder while loading
- **Error handling**: Fallback when cover image fails
- **Rich metadata display**: Rating, page count, genres
- **Accessibility**: Proper alt text and ARIA labels
- **Performance**: Optimized images with Next.js

**Image Handling**:
```tsx
{book.cover_url ? (
  <Image
    src={book.cover_url}
    alt={`Cover of ${book.title}`}
    width={112}
    height={168}
    className="object-cover transition-all duration-300"
    onError={(e) => {
      // Hide broken image, show fallback
      const target = e.target as HTMLImageElement;
      target.style.display = 'none';
      target.nextElementSibling?.classList.remove('hidden');
    }}
  />
) : (
  <div className="fallback-cover">
    <BookOpen className="icon" />
    <span>No Cover</span>
  </div>
)}
```

---

## Cache Architecture

### File-Based Caching System

#### Cache Directory Structure
```
backend/cache/
├── recommendations/        # API recommendation responses
│   ├── md5hash1.json      # Cached unified recommendation
│   ├── md5hash2.json      # Another cached recommendation
│   └── ...
├── books/                 # Book metadata from Hardcover
│   ├── md5hash3.json      # "Neuromancer" by William Gibson
│   ├── md5hash4.json      # "Dune" by Frank Herbert
│   └── ...
└── taste_profiles/        # Future: User taste profiles
    └── (empty)
```

#### Cache File Format
```json
{
  "value": {
    "recommendations": [...],
    "insights": {...},
    "processing_time": 2.34,
    "cache_hit": false
  },
  "created_at": "2025-01-11T19:45:30.123456",
  "expired_at": "2025-01-11T20:45:30.123456",
  "key": "matrix,inception,blade_runner:{}:unified",
  "cache_type": "recommendations"
}
```

#### Cache Key Generation Strategies

##### Recommendation Cache Keys
```python
def create_recommendation_cache_key(movies: List[str], preferences: Optional[Dict], rec_type: str) -> str:
    # Normalize movies (sort for consistency)
    movies_normalized = sorted([movie.lower().strip() for movie in movies])
    
    # Normalize preferences
    preferences_normalized = json.dumps(preferences or {}, sort_keys=True)
    
    # Create composite key
    key_data = f"{movies_normalized}:{preferences_normalized}:{rec_type}"
    
    # Generate MD5 hash for safe filename
    return hashlib.md5(key_data.encode()).hexdigest()
```

**Example Keys**:
- `movies=["The Matrix", "Inception"], preferences={}, type="unified"` 
  → `"7a8b9c1d2e3f4g5h6i7j8k9l0m1n2o3p"`

##### Book Cache Keys
```python  
def create_book_cache_key(title: str, author: str) -> str:
    # Normalize book identifiers
    title_clean = title.lower().strip()
    author_clean = author.lower().strip()
    
    # Create composite key
    key_data = f"book:{title_clean}:{author_clean}"
    
    return hashlib.md5(key_data.encode()).hexdigest()
```

#### Cache Expiration Strategy

| Cache Type | Default TTL | Rationale |
|------------|-------------|-----------|
| **Recommendations** | 1 hour (3600s) | Taste preferences may change, but not frequently |
| **Books** | 24 hours (86400s) | Book metadata rarely changes |
| **Taste Profiles** | 2 hours (7200s) | More dynamic, user-dependent data |

#### Cache Operations

##### Get Operation
```python
async def get(self, key: str, cache_type: str = "recommendations") -> Optional[Any]:
    cache_file = self._get_cache_file_path(key, cache_type)
    
    try:
        if not cache_file.exists():
            return None
        
        # Read cache file
        async with aiofiles.open(cache_file, 'r') as f:
            content = await f.read()
            cache_data = json.loads(content)
        
        # Check expiration
        expired_at = datetime.fromisoformat(cache_data['expired_at'])
        if datetime.now() > expired_at:
            # Remove expired cache
            await self._remove_cache_file(cache_file)
            return None
        
        return cache_data['value']
        
    except (json.JSONDecodeError, KeyError, ValueError, OSError):
        # Remove corrupted cache
        await self._remove_cache_file(cache_file)
        return None
```

##### Set Operation
```python
async def set(self, key: str, value: Any, expire: int = 3600, cache_type: str = "recommendations"):
    cache_file = self._get_cache_file_path(key, cache_type)
    
    try:
        # Calculate expiration
        expired_at = datetime.now() + timedelta(seconds=expire)
        
        # Prepare cache data
        cache_data = {
            'value': value,
            'created_at': datetime.now().isoformat(),
            'expired_at': expired_at.isoformat(),
            'key': key,
            'cache_type': cache_type,
        }
        
        # Serialize with custom handler for Pydantic models
        cache_json = json.dumps(cache_data, default=self._json_serializer, indent=2)
        
        # Write to file
        async with aiofiles.open(cache_file, 'w') as f:
            await f.write(cache_json)
            
    except Exception as e:
        logger.error(f"Error caching {cache_type} data: {e}")
```

#### Cache Cleanup System
```python
async def _cleanup_expired_cache(self):
    """Background task to clean expired cache files"""
    while True:
        try:
            current_time = datetime.now()
            
            # Check all cache directories
            for cache_type in ["recommendations", "books", "taste_profiles"]:
                cache_dir = self.cache_dir / cache_type
                
                for cache_file in cache_dir.glob("*.json"):
                    try:
                        # Read and check expiration
                        async with aiofiles.open(cache_file, 'r') as f:
                            content = await f.read()
                            cache_data = json.loads(content)
                        
                        expired_at = datetime.fromisoformat(cache_data['expired_at'])
                        if current_time > expired_at:
                            await self._remove_cache_file(cache_file)
                            
                    except Exception:
                        # Remove corrupted files
                        await self._remove_cache_file(cache_file)
            
            # Sleep for 1 hour before next cleanup
            await asyncio.sleep(3600)
            
        except Exception as e:
            logger.error(f"Cache cleanup error: {e}")
            await asyncio.sleep(3600)  # Continue despite errors
```

---

## Dependencies & Integrations

### Backend Dependencies (`backend/requirements.txt`)

#### Core Framework Dependencies
```python
fastapi==0.115.4                 # Modern, fast web framework
uvicorn[standard]==0.32.1        # ASGI server with WebSocket support
python-multipart==0.0.12         # Form data parsing
pydantic==2.10.3                 # Data validation and serialization
pydantic-settings==2.6.1         # Settings management
```

#### HTTP Client & External APIs
```python
httpx==0.28.1                    # Async HTTP client for external APIs
openai==1.55.3                   # OpenAI API client (also works with Groq)
```

#### File & Environment Handling
```python
aiofiles==24.1.0                 # Async file operations for caching
python-dotenv==1.0.1             # Environment variable loading
```

#### Development & Testing (Optional)
```python
pytest==8.3.4                   # Testing framework
pytest-asyncio==0.24.0           # Async testing support
black==24.10.0                   # Code formatting
flake8==7.1.1                    # Code linting
requests==2.32.3                 # Synchronous HTTP (health checks)
```

### Frontend Dependencies (`frontend/package.json`)

#### Core Framework
```json
{
  "next": "15.4.1",              // React framework with App Router
  "react": "19.1.0",             // UI library (latest version)
  "react-dom": "19.1.0"          // DOM rendering
}
```

#### UI & Animation Libraries
```json
{
  "framer-motion": "^12.23.6",   // Animation library
  "lucide-react": "^0.525.0",    // Icon library
  "@radix-ui/react-dialog": "^1.1.14",    // Modal components
  "@radix-ui/react-slider": "^1.3.5",     // Slider components
  "@radix-ui/react-slot": "^1.2.3",       // Composition utility
  "@radix-ui/react-tabs": "^1.1.12"       // Tab components
}
```

#### Styling & Utilities
```json
{
  "tailwindcss": "^4",                     // CSS framework
  "tailwind-merge": "^3.3.1",             // Conditional class merging
  "tailwind-variants": "^1.0.0",          // Variant generation
  "class-variance-authority": "^0.7.1",    // Component variants
  "clsx": "^2.1.1"                        // Conditional classnames
}
```

#### Development Dependencies
```json
{
  "@types/node": "^20.19.8",              // Node.js type definitions
  "@types/react": "^19.1.8",              // React type definitions
  "@types/react-dom": "^19.1.6",          // React DOM type definitions
  "typescript": "^5",                      // TypeScript compiler
  "eslint": "^9",                          // Code linting
  "eslint-config-next": "15.4.1"          // Next.js ESLint config
}
```

### External Service Integration Details

#### OpenAI Integration
**Service Class**: `GPTService` (`backend/app/services/gpt_service.py`)
**Purpose**: AI-powered recommendation generation
**Configuration**:
```python
self.client = openai.AsyncOpenAI(
    api_key=settings.openai_api_key,
    base_url=settings.openai_base_url  # Configurable for Groq
)
```

**Usage Pattern**:
1. Build prompt from movies and preferences
2. Send to chat completion endpoint
3. Parse JSON response with fallback handling
4. Convert to application data models

**Rate Limiting**: External API limits (varies by provider)
**Error Handling**: Fallback response generation on API failure

#### Groq Integration (Alternative to OpenAI)
**Configuration**: Same `GPTService` with different base URL
**Model**: `llama-3.3-70b-versatile` (configured in environment)
**Benefits**: Faster inference, competitive quality
**Rate Limits**: 30 requests/minute (free tier)

#### Hardcover API Integration
**Service Class**: `HardcoverService` (`backend/app/services/hardcover_service.py`)
**Purpose**: Book metadata enrichment (covers, ratings, descriptions)
**Authentication**: JWT Bearer token
**API Type**: GraphQL

**Search Strategies**:
1. Combined title + author search
2. Title-only search
3. Cleaned title search (stop words removed)
4. Author + title (reversed order)

**Matching Algorithm**:
- String similarity scoring
- Popularity weighting
- Configurable threshold (currently 7.0)

#### TMDB Integration
**Service Class**: `TMDBService` (`frontend/src/service/tmdb.ts`)
**Purpose**: Movie search and poster images
**Authentication**: Bearer token (Read Access Token)
**API Type**: REST

**Features**:
- Movie search with autocomplete
- Poster image URL generation
- Movie metadata (ratings, release dates)
- Popularity-based sorting

### Integration Architecture

#### Service Communication Pattern
```
Frontend → Backend API → External Services
    ↓           ↓              ↓
React      FastAPI      OpenAI/Groq
Components  Routers     Hardcover
            Services    TMDB
```

#### Data Flow Integration
```
TMDB (Movies) → Frontend Selection → Backend Processing → AI Analysis → Book Enhancement
      ↓                ↓                    ↓               ↓              ↓
  Movie metadata   User choices      Recommendation    AI response   Hardcover data
```

#### Error Handling Integration
- **Service Level**: Each service handles its own API errors
- **Router Level**: Catches service errors, returns HTTP responses
- **Frontend Level**: Handles HTTP errors, shows user messages
- **Fallback Strategy**: Graceful degradation at each level

#### Caching Integration
- **Backend**: File-based caching for all external API responses
- **Frontend**: No explicit caching (relies on browser cache)
- **External APIs**: Respect rate limits through caching

---

## Navigation
- **Previous**: [02-technical-implementation.md](./02-technical-implementation.md) - Technical implementation details
- **Current**: 03-apis-and-data-flow.md
- **Next**: [04-code-quality-and-gaps.md](./04-code-quality-and-gaps.md) - Code quality assessment and improvement recommendations
- **Related**: [01-overview-and-architecture.md](./01-overview-and-architecture.md) - System overview and architecture